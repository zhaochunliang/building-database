extends layout_new

block content
  div#vizicities-viewport
  div#building-map

  section.container
    div.col-5.details
      h1 #{building.name}

      p #{building.locality.district}, #{building.locality.country}
        if building.locality.countryCode
          flag-icon(key="#{building.locality.countryCode}" img)

      each model, key in building.models.raw
        - var size = (model.fileSize) ? (model.fileSize / 1000).toFixed(2) : 0;
        button(href="/api/building/#{building._id}/download/raw/#{model.type}") Download .#{model.type} (#{size} KB)
      each model, key in building.models.zip
        - var size = (model.fileSize) ? (model.fileSize / 1000).toFixed(2) : 0;
        button(href="/api/building/#{building._id}/download/zip/#{model.type}") Download #{model.type} zip (#{size} KB)
      button(href="/api/building/#{building._id}.kml") Download .kml

      a.license(rel="license", href="http://creativecommons.org/licenses/by-sa/4.0/")
        img(alt="Creative Commons License", style="border-width:0", src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png")

      hr

      ul
        li #{building.stats.downloads} downloads
        li #{building.structure.faces} faces
        if building.osm.id
          li
            a(href="http://www.openstreetmap.org/#{building.osm.type}/#{building.osm.id}") View on OpenStreetMap
        li Added by 
          a(href="/search/user/#{buildingUser.id}") #{buildingUser.username}
        li 
          a(href="/search/near/#{building.location.coordinates[0]}/#{building.location.coordinates[1]}/1000") See nearby buildings
      hr
      p
        a(href="/building/#{building._id}/report") Report building
        if (user && user._id.toString() === buildingUser.id.toString())
          a.right(href="/add/location/#{building._id}") Edit location

  script(src="/lib/webcomponentsjs/webcomponents.min.js")
  link(rel="import" href="/lib/flag-icon/flag-icon.html")

  link(rel="stylesheet", href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css")
  script(src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.js")

  link(rel="stylesheet", href="/lib/vizicities/vizi.css")
  script(src="/lib/vizicities/vizi.min.js")
  script.
    var map = L.map("building-map", {zoomControl:false}).setView([#{building.location.coordinates[1]}, #{building.location.coordinates[0]}], 16);

    // Offset map
    map.panBy(L.point(-330, 50), {animate: false});

    // Disable drag and zoom handlers.
    map.dragging.disable();
    map.touchZoom.disable();
    map.doubleClickZoom.disable();
    map.scrollWheelZoom.disable();

    // Disable tap handler, if present.
    if (map.tap) map.tap.disable();

    //- L.tileLayer("http://{s}.tile.osm.org/{z}/{x}/{y}.png", {
    L.tileLayer("http://{s}.tile.stamen.com/toner-lite/{z}/{x}/{y}.png", {
      //- attribution: "&copy; <a href='http://osm.org/copyright'>OpenStreetMap</a> contributors"
      attribution: "&copy; <a href='http://stamen.com'>Stamen</a> & <a href='http://osm.org/copyright'>OpenStreetMap</a> contributors"
    }).addTo(map);

    var world = new VIZI.World({
      viewport: document.querySelector("#vizicities-viewport"),
      center: new VIZI.LatLon(#{building.location.coordinates[1]}, #{building.location.coordinates[0]})
    });

    var controls = new VIZI.ControlsMap(world.camera, {
      viewport: world.options.viewport
    });
    
    controls.controls.rotateUp(-16 * Math.PI / 180)
    controls.controls.dollyOut(1.15);
    controls.controls.autoRotate = true;

    var mapConfig = {
      input: {
        type: "BlueprintInputStaticMapImage",
        options: {
          imagePath: "https://a.tiles.mapbox.com/v3/examples.map-i86l3621/{lon},{lat},{z}/{w}x{h}@2x.png"
        }
      },
      output: {
        type: "BlueprintOutputImage",
        options: {
          distance: 200, // Distance from center in metres
          shadowTexture: "/images/vizicities-shadow.png"
        }
      },
      triggers: [{
        triggerObject: "output",
        triggerName: "initialised",
        triggerArguments: ["bounds"],
        actionObject: "input",
        actionName: "requestImage",
        actionArguments: ["bounds"],
        actionOutput: {
          bounds: "bounds"
        }
      }, {
        triggerObject: "input",
        triggerName: "imageReceived",
        triggerArguments: ["image"],
        actionObject: "output",
        actionName: "outputImage",
        actionArguments: ["image"],
        actionOutput: {
          image: "image"
        }
      }]
    };

    var switchboardMap = new VIZI.BlueprintSwitchboard(mapConfig);
    switchboardMap.addToWorld(world);

    var colladaConfig = {
      input: {
        type: "BlueprintInputKML",
        options: {
          path: "/api/building/#{building._id}.kml"
        }
      },
      output: {
        type: "BlueprintOutputCollada",
        options: {}
      },
      triggers: [{
        triggerObject: "output",
        triggerName: "initialised",
        triggerArguments: [],
        actionObject: "input",
        actionName: "requestData",
        actionArguments: [],
        actionOutput: {}
      }, {
        triggerObject: "input",
        triggerName: "dataReceived",
        triggerArguments: ["kml"],
        actionObject: "output",
        actionName: "outputCollada",
        actionArguments: ["collada"],
        actionOutput: {
          collada: {
            process: "map",
            itemsObject: "kml",
            itemsProperties: "placemark.model",
            transformation: {
              coordinates: ["location.longitude", "location.latitude"],
              modelPath: "link.href"
            }
          }
        }
      }]
    };

    var switchboardCollada = new VIZI.BlueprintSwitchboard(colladaConfig);
    switchboardCollada.addToWorld(world);

    var clock = new VIZI.Clock();

    var update = function() {
      var delta = clock.getDelta();

      controls.onTick(delta);

      world.onTick(delta);
      world.render();

      window.requestAnimationFrame(update);
    };

    update();

    var checkColladaMaterials = function(node, colour) {
      if (node.material) {
        // console.log(node.material);
        if (node.material.materials) {
          var loaded = true;
          var newMaterials = [];
          for (var i = 0; i < node.material.materials.length; i++) {
            var material = node.material.materials[i];
            if (!material.map || (material.map && !material.map.image)) {
              loaded = false;
              newMaterials.push(new THREE.MeshLambertMaterial({color: colour}));
            }
          }

          if (!loaded) {
            node.material = new THREE.MeshFaceMaterial(newMaterials);
          }
        } else {
          if (!node.material.map || (node.material.map && !node.material.map.image)) {
            node.material = new THREE.MeshLambertMaterial({color: colour});
          }
        }
      }

      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          checkColladaMaterials(node.children[i], colour);
        }
      }
    }
    
    // TODO: Work out a way to do this without a timeout
    setTimeout(function() {
      // Check for unloaded materials and replace with default colour
      checkColladaMaterials(world.layers[1].object.children[0], 0xffffff);
    }, 1000);